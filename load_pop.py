import os
from collections import defaultdict

import covasim.utils as cvu
import numpy as np
import pandas as pd

dirname = os.path.dirname(os.path.abspath(__file__))
#dirname = 'C:\\Users\\nick.scott\\Desktop\\Github\\covasim-australia'
def clusters_to_contacts(clusters):
    """
    Convert clusters to contacts

    cluster of people [1,2,3] would result in contacts
        1: [2,3]
        2: [1,3]
        3: [1,2]

    """
    contacts = defaultdict(set)
    for cluster in clusters:
        for i in cluster:
            for j in cluster:
                if j <= i:
                    pass
                else:
                    contacts[i].add(j)
                    contacts[j].add(i)

    return {x: np.array(list(y)) for x, y in contacts.items()}

def random_contacts(include, mean_contacts_per_person):
    """
    Sample random contacts

    Note that random contacts are directed and asymmetric (e.g. Person 1 can transmit to Person 2 but not vice-versa).

    The `include` argument allows a subset of the population to be selected

    Args:
        include: Boolean array with length equal to population size, containing True if the person is eligible for contacts
        mean_contacts_per_person: Mean number of contacts (Poisson distribution)

    Returns:
        Dictionary {1:[2,3,4],2:[1,5,6]} with keys for source person, and a values being a list of target contacts.

    """
    # Weights should have the same number of entries as the total population size
    contacts = {}
    include_inds = np.nonzero(include)[0]
    n_eligible = len(include_inds)
    for p in range(len(include)):
        n_contacts = cvu.poisson(mean_contacts_per_person)  # Draw the number of Poisson contacts for this person
        contact_inds = cvu.choose(n_eligible, min(n_eligible, n_contacts))  # Choose people at random. These index the include_inds array
        contacts[p] = include_inds[contact_inds] # Convert the sampled indexes to the actual person IDs
    return contacts

def get_mixing_matrix(databook_path, sheet_name: str):
    """
    Load Prem et al. matrices
    """
    mixing_matrix = pd.read_excel(dirname + '/' + databook_path, sheet_name=sheet_name, usecols=range(17), index_col=0)
    bin_lower = [int(x.split('-')[0]) for x in mixing_matrix.index]
    bin_upper = [int(x.split('-')[1]) for x in mixing_matrix.index]
    return mixing_matrix, bin_lower, bin_upper

def sample_household_cluster(mixing_matrix, bin_lower, bin_upper, reference_age, n):
    """
    Return list of ages in a household/location based on mixing matrix and reference person age
    """

    ages = [reference_age]  # The reference person is in the household/location

    if n > 1:
        idx = np.digitize(reference_age, bin_lower) - 1  # First, find the index of the bin that the reference person belongs to
        p = mixing_matrix.iloc[idx, :]
        sampled_bins = np.random.choice(len(bin_lower), n - 1, replace=True, p=p / sum(p))

        for bin in sampled_bins:
            ages.append(int(round(np.random.uniform(bin_lower[bin]-0.5, bin_upper[bin]+0.5))))

    return np.array(ages)


def get_australian_popdict(databook_path, pop_size=100, contact_numbers={'H': 4,'S': 22,'W': 20,'C': 20}, population_subsets = None):
    """
    Make a population specification for CovaSim from Australian data and Prem matrices
    """

    reference = pd.read_excel(dirname + '/' + databook_path, sheet_name='age_sex')['Total']
    reference.iloc[0:18] = 0
    reference.iloc[18:28] = reference.iloc[18:28] * np.linspace(0.1, 1, 10)

    household_dist = pd.read_excel(dirname + '/' + databook_path, sheet_name='households')['no. households']  # Household size distribution
    # calculate the population size generated by the household data, so that the household distribution can be scaled based no model population
    household_dist.index = household_dist.index + 1  # Convert from index to number of people in the household (starting at 1)
    # Calculate the number of households we need to fill to meet the population size requirement
    n_households = (pop_size * (household_dist / sum(household_dist.index * household_dist))).round().astype(int)
    n_households[1] += pop_size - sum(n_households * n_households.index)  # Adjust single-person households to fill the gap

    # Select the ages of the heads of households
    household_heads = np.random.choice(reference.index, sum(n_households), p=reference.values / sum(reference.values))
    #plt.hist(household_heads, bins=max(household_heads) - min(household_heads))
    popdict = {}
    popdict['uid'] = np.arange(pop_size)  # Assign UIDs
    popdict['age'] = []
    contacts = {}  # store dict of contact dicts e.g. {'H':{1:[2,3],2:[1,3]...}}

    # Create households+people and store ages
    household_clusters = []
    mixing_matrix, bin_lower, bin_upper = get_mixing_matrix(databook_path, 'contact matrices-home')
    households_completed = 0
    people_added = 0
    for household_size in n_households.index:
        for i in range(n_households.loc[household_size]):
            household_ages = sample_household_cluster(mixing_matrix, bin_lower, bin_upper, household_heads[households_completed], household_size)
            household_indexes = np.arange(people_added, people_added + household_size)  # Get the person IDs for these new people (just increments automatically)
            household_clusters.append(household_indexes.tolist())  # Put the people into the households
            popdict['age'] += household_ages.tolist()  # Add their ages to the age list

            households_completed += 1
            people_added += household_size

    popdict['age'] = np.array(popdict['age'])
    contacts['H'] = clusters_to_contacts(household_clusters)

    # Create random school contacts (only certain ages eligible)
    classroom_size = contact_numbers['S']
    contacts['S'] = random_contacts((popdict['age'] >= 5) & (popdict['age'] <= 18), classroom_size)

    # Create random work contacts (only certain ages eligible)
    workplace_size = contact_numbers['W']
    contacts['W'] = random_contacts((popdict['age'] > 18) & (popdict['age'] <= 65), workplace_size)

    # Create random community contacts
    social_size = contact_numbers['C']
    contacts['C'] = random_contacts(popdict['age'], social_size)

    extra_layers = {k: v for k, v in contact_numbers.items() if k not in {'H','W','S','C'}}
    for i, key in enumerate(extra_layers.keys()):
        n_layer = int(population_subsets['proportion'][key] * pop_size)
        inds = np.random.choice(popdict['uid'][(popdict['age'] > population_subsets['age_lb'][key]) & (popdict['age'] < population_subsets['age_ub'][key])], n_layer)
        if population_subsets['cluster_type']=='complete':
            contacts[key] = clusters_to_contacts([inds])

        if population_subsets['cluster_type']=='random':
            x = np.zeros_like(popdict['age'])
            x[inds] = 1
            n_contacts_per_layer = contact_numbers[key]
            contacts[key] = random_contacts(x, n_contacts_per_layer)

    # Assign sexes
    sexes = pd.read_excel(dirname + '/' + databook_path, sheet_name = 'age_sex')
    sexes['frac_male'] = sexes['Male'] / (sexes['Male'] + sexes['Female'])  # Get fraction male
    sexes['frac_male'] = sexes['frac_male'].fillna(0.5)  # Fill NaNs with 0.5 (in cases where there were 0 people of either sex
    probability_male = sexes.loc[popdict['age'], 'frac_male']
    popdict['sex'] = np.random.binomial(1, probability_male) # nb. 1 means male

    # Convert contacts into the format expected by Covasim
    popdict['contacts'] = []
    for i in range(0,pop_size):
        d = {layer: contacts[layer][i] if i in contacts[layer] else [] for layer in contacts}
        popdict['contacts'].append(d)

    return popdict


# if __name__ == '__main__':
#     # This block allows quickly running this file directly to test the functions and set breakpoints
#     import sciris as sc
#     with sc.Timer() as t:
#         popdict = get_australian_popdict()


