import os
from collections import defaultdict

import covasim.utils as cvu
import numpy as np
import pandas as pd


dirname = os.path.dirname(os.path.abspath(__file__))
def clusters_to_contacts(clusters):
    """
    Convert clusters to contacts

    cluster of people [1,2,3] would result in contacts
        1: [2,3]
        2: [1,3]
        3: [1,2]

    """
    contacts = defaultdict(set)
    for cluster in clusters:
        for i in cluster:
            for j in cluster:
                if j <= i:
                    pass
                else:
                    contacts[i].add(j)
                    contacts[j].add(i)

    return {x: np.array(list(y)) for x, y in contacts.items()}


def random_contacts(include, mean_contacts_per_person):
    """
    Sample random contacts

    Note that random contacts are directed and asymmetric (e.g. Person 1 can transmit to Person 2 but not vice-versa).

    The `include` argument allows a subset of the population to be selected

    Args:
        include: Boolean array with length equal to population size, containing True if the person is eligible for contacts
        mean_contacts_per_person: Mean number of contacts (Poisson distribution)

    Returns:
        Dictionary {1:[2,3,4],2:[1,5,6]} with keys for source person, and a values being a list of target contacts.

    """
    # Weights should have the same number of entries as the total population size
    contacts = {}
    include_inds = np.nonzero(include)[0]
    n_eligible = len(include_inds)
    for p in range(len(include)):
        if include[p] == 0:
            contacts[p] = []
        else:
            n_contacts = cvu.poisson(mean_contacts_per_person)  # Draw the number of Poisson contacts for this person
            contact_inds = cvu.choose(n_eligible-1, min(n_eligible-1, n_contacts))  # Choose people at random. These index the include_inds array
            include_inds_minus_self = np.delete(include_inds, np.where(include_inds == p)) # need to exclude being a contact of themselves
            contacts[p] = include_inds_minus_self[contact_inds] # Convert the sampled indexes to the actual person IDs
    return contacts

def create_clustering(people_to_cluster, mean_cluster_size):
    #This function puts people into disconnected clusters. Everyone in each cluster is connected to one another
    clusters = []
    while len(people_to_cluster)>0:
        new_cluster_size = max(cvu.poisson(mean_cluster_size),2)
        new_cluster = np.random.choice(people_to_cluster, min(len(people_to_cluster), new_cluster_size), replace=False)
        clusters.append(new_cluster.tolist())
        people_to_cluster = [x for x in people_to_cluster if x not in new_cluster]
    return clusters

def get_mixing_matrix(setting, databook_path, sheet_name: str):
    """
    Load Prem et al. matrices
    """
    mixing_matrix = pd.read_excel(databook_path, sheet_name=sheet_name, index_col=[0, 1])
    mixing_matrix = mixing_matrix.loc[(setting, slice(None)), :]
    mixing_matrix = mixing_matrix.reset_index()
    mixing_matrix = mixing_matrix.set_index('Age group')
    mixing_matrix = mixing_matrix.drop(columns=["Location", "Total"])

    bin_lower = [int(x.split('-')[0]) for x in mixing_matrix.index]
    bin_upper = [int(x.split('-')[1]) for x in mixing_matrix.index]
    return mixing_matrix, bin_lower, bin_upper

def sample_household_cluster(mixing_matrix, bin_lower, bin_upper, reference_age, n):
    """
    Return list of ages in a household/location based on mixing matrix and reference person age
    """

    ages = [reference_age]  # The reference person is in the household/location

    if n > 1:
        idx = np.digitize(reference_age, bin_lower) - 1  # First, find the index of the bin that the reference person belongs to
        p = mixing_matrix.iloc[idx, :]
        sampled_bins = np.random.choice(len(bin_lower), n - 1, replace=True, p=p / sum(p))

        for bin in sampled_bins:
            ages.append(int(round(np.random.uniform(bin_lower[bin]-0.5, bin_upper[bin]+0.5))))

    return np.array(ages)


def get_country_popdict(databook_path, pop_size=100, contact_numbers={'H': 4,'S': 22,'W': 20,'C': 20}, population_subsets = None, setting=None):
    """
    Make a population specification for CovaSim from Australian data and Prem matrices
    """

    reference = pd.read_excel(databook_path, sheet_name='age_sex', index_col=[0, 1])
    age_groups = list(reference.columns)[0:16]
    reference = reference.loc[(setting, 'Total'), :]


    for i in range(80):
        reference['{}'.format(i)] = reference[age_groups[int(np.floor(i / 5))]] / 5

    reference = reference[['{}'.format(i) for i in range(80)]]

    reference.iloc[0:18] = 0
    reference.iloc[18:28] = reference.iloc[18:28] * np.linspace(0.1, 1, 10)

    household_dist = pd.read_excel(dirname + '/' + databook_path, sheet_name='households', index_col=0)  # Household size distribution
    # calculate the population size generated by the household data, so that the household distribution can be scaled based no model population
    # Calculate the number of households we need to fill to meet the population size requirement
    n_households = (pop_size * (household_dist.loc[setting, :]/100)).round().astype(int)
    n_households.index = list(range(1, 7))
    n_households = (n_households/n_households.index).astype(np.int)
    n_households[1] += pop_size - sum(n_households * n_households.index)

    # Select the ages of the heads of households
    household_heads = np.random.choice(reference.index, sum(n_households), p=reference.values / sum(reference.values))
    #plt.hist(household_heads, bins=max(household_heads) - min(household_heads))
    popdict = {}
    popdict['uid'] = np.arange(pop_size)  # Assign UIDs
    popdict['age'] = []
    contacts = {}  # store dict of contact dicts e.g. {'H':{1:[2,3],2:[1,3]...}}

    # Create households+people and store ages
    household_clusters = []
    mixing_matrix, bin_lower, bin_upper = get_mixing_matrix(setting, databook_path, 'contact matrices-home')
    households_completed = 0
    people_added = 0
    for household_size in n_households.index:
        for i in range(n_households.loc[household_size]):
            household_ages = sample_household_cluster(mixing_matrix, bin_lower, bin_upper, household_heads[households_completed], household_size)
            household_indexes = np.arange(people_added, people_added + household_size)  # Get the person IDs for these new people (just increments automatically)
            household_clusters.append(household_indexes.tolist())  # Put the people into the households
            popdict['age'] += household_ages.tolist()  # Add their ages to the age list

            households_completed += 1
            people_added += household_size

    popdict['age'] = np.array(popdict['age']).astype(np.int)
    contacts['H'] = clusters_to_contacts(household_clusters)

    # Create school contacts, with children of each age clustered in groups
    classrooms = []
    for a in range(5,18):
        children_to_allocate = popdict['uid'][popdict['age'] == a]
        classrooms.extend(create_clustering(children_to_allocate, contact_numbers['S']))
    for i in range(len(classrooms)): # add a random adult to each classroom as the teacher
        classrooms[i].extend([np.random.choice(popdict['uid'][popdict['age'] > 18])])

    contacts['S'] = clusters_to_contacts(classrooms)

    # Create random work contacts (only certain ages eligible)
    workplaces = []
    workplaces.extend(create_clustering(popdict['uid'][(popdict['age'] > 18) & (popdict['age'] <= 65)], contact_numbers['W']))
    contacts['W'] = clusters_to_contacts(workplaces)

    # Create random community contacts
    social_size = contact_numbers['C']
    contacts['C'] = random_contacts(popdict['age'], social_size)

    extra_layers = {k: v for k, v in contact_numbers.items() if k not in {'H','W','S','C'}}
    for i, key in enumerate(extra_layers.keys()):
        n_layer = int(population_subsets['proportion'][key] * pop_size)
        inds = np.random.choice(popdict['uid'][(popdict['age'] > population_subsets['age_lb'][key]) & (popdict['age'] < population_subsets['age_ub'][key])], n_layer)
        x = np.zeros_like(popdict['age'])
        x[inds] = 1

        if population_subsets['cluster_type'][key] == 'complete':
            contacts[key] = clusters_to_contacts([inds])

        if population_subsets['cluster_type'][key] == 'random':
            n_contacts_per_layer = contact_numbers[key]
            contacts[key] = random_contacts(x, n_contacts_per_layer)

        if population_subsets['cluster_type'][key] == 'clusters':
            miniclusters = []
            miniclusters.extend(create_clustering(popdict['uid'][(popdict['age'] > population_subsets['age_lb'][key]) & (popdict['age'] < population_subsets['age_ub'][key])], contact_numbers[key]))
            contacts[key] = clusters_to_contacts(miniclusters)

        if population_subsets['cluster_type'][key] == 'partition':
            x = np.zeros_like(popdict['age'])
            x[inds] = 1
            y = np.ones_like(popdict['age'])
            y[inds] = 0
            n_contacts_per_layer = contact_numbers[key]
            contacts[key] = random_contacts(x, n_contacts_per_layer)
            part2 = random_contacts(y, n_contacts_per_layer)
            for j in range(pop_size):
                if  contacts[key][j] == []:
                    contacts[key][j] = part2[j]

    # Assign sexes
    sexes = pd.read_excel(databook_path, sheet_name='age_sex', index_col=[0, 1])
    age_groups = list(sexes.columns)[0:16]
    sexes = sexes.loc[(setting, ['Total', 'Male']), :]
    sexes = sexes.transpose()

    for i in range(80):
        sexes.loc['{}'.format(i), :] = sexes.loc[age_groups[int(np.floor(i / 5))], :] / 5
    sexes = sexes.loc[['{}'.format(i) for i in range(80)], :]
    sexes.loc['80', :] = sexes.loc['79', :]

    frac_male = sexes.loc[:, (setting, 'Male')] / sexes.loc[:, (setting, 'Total')]  # Get fraction male
    frac_male =frac_male.fillna(0.5)  # Fill NaNs with 0.5 (in cases where there were 0 people of either sex
    probability_male = frac_male[np.array(popdict['age']).astype(np.str)]
    popdict['sex'] = np.random.binomial(1, probability_male) # nb. 1 means male

    # Convert contacts into the format expected by Covasim
    popdict['contacts'] = []
    for i in range(0,pop_size):
        d = {layer: contacts[layer][i] if i in contacts[layer] else [] for layer in contacts}
        popdict['contacts'].append(d)

    return popdict